import os
import sys
import numpy as np
from sklearn.model_selection import train_test_split 
import tensorflow as tf
from tensorflow import keras
import matplotlib.pyplot as plt
from numpy.random import RandomState

# add parent directory of project to system path, to access all the packages in project, sys.path.append appends are not permanent
sys.path.append(os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))))

from src.model.VAEGAN.VAEGAN import VAEGAN
from src.data.toy_models.ParabolicModel import ParabolicModel
from src.data.toy_models.SineModel import SineModel 
from src.data.toy_models.TrueModel import TrueModel

latent_dim = 20
epochs = 10
batch_size = 1 
input_size = 2048
n_classes = 3
train_size = 26000 
buffer_size = train_size 

prng = RandomState(123)
# generate z
z_obs = prng.uniform(0,1,580)

#Model 1 and Model 2 have similar distributions as
#shown in Figure 2. Given the observations xobs,real which
#are generated by the underlying model ytrue = −3.5z
#2 +
#3.6z − 0.1 on zobs = {z1, z2, · · · , z580} with an error
#matrix Σobs, we would like to fit the two toy models to
#the observations to tell which one is most probable to be
#the true model, and interpolate the data with the model at
#z
#∗ = {z
#∗
#1
#, · · · , z∗
#M }, for example, z
#∗
#even staying in the
#interval [0, 1] with M = 1468.
# generate an 580 z observations in [0,1] along with error matrix

trueModelObj = TrueModel()
x_obs = trueModelObj.out(z_obs)

#dataset = tf.data.Dataset.from_tensor_slices(x).batch(580)

#x_obs_err = 

checkpoint_path = "./saved_models/cp.ckpt"

vaegan = VAEGAN(latent_dim, input_size, n_classes)

# Load the weights using the `checkpoint_path` format
vaegan.load_weights(checkpoint_path)
predictions, _ = vaegan.discriminator(x_obs)
interpolations, _ = vaegan.generator(vae.encoder(x_obs))
print(predictions)
plt.scatter(z_obs, x_obs)

plt.show()
